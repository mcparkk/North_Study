## 서버 확장과 로드 밸런싱

![](https://img.hani.co.kr/imgdb/resize/2019/0101/00502362_20190101.JPG)

인터넷 이용자가 전 세계 인구의 절반을 넘어버린 대 정보화 시대
인기 있는 웹 사이트는 수 없이 많은 트래픽을 감당해야 한다

따라서 대용량의 트래픽을 처리하거나, 기존보다 트래픽이 증가하는 경우 서버 확장을 고려하게 되는데 서버를 확장하는 방식으로 수평 확장, 수직 확장이 있다.

![](https://cdn.maily.so/kmi53bxhp4n4bekqfrewdyyjn728)

간단하게 **수직 확장(Scale Up)** 방식은 서버 자체의 성능을 높이는 방식으로 CPU나 메모리, 스토리지 등의 하드웨어 자원을 추가하여 서버의 성능을 높인다. 이는 **단일 서버에서 성능이 향상**되기 때문에 시스템 구조가 단순해지고 관리하기가 용이하다. 하지만 **하드웨어 업그레이드에서 제한이 있거나 특정 지점에서 성능 한계에 도달**할 수 있다.

**수평 확장(Scale Out)** 방식은 동일한 서버를 여러 대를 추가하여 트래픽을 분산하는 방법이다. 이 방식은 **성능 한계에 민감하지 않고 확장성이 높다. 또한 클라우드 환경에서 탄력적으로 운용이 가능하다.** 하지만 **서버가 분산**되기 때문에 **데이터 일관성을 유지하고, 각 서버간 통신을 처리하기 위해 추가적인 복잡성이 발생**한다.

위의 수평 확장 방식은 **서버를 계속 추가하기만 해도 성능을 확장**할 수 있지만, 이러한 다수의 서버에서 부하가 균등하게 분배되지 않으면 성능 향상의 효과가 줄어들거나 특정 서버에 과부하가 발생할 수 있다.

이를 가능하게 하는것이 **로드 밸런싱(Load Balancing)** 이다.

## 로드 밸런싱 방식

로드 밸런싱은 클라이언트의 요청을 여러 서버에 분산하여 특정 서버에 과부하가 발생하지 않도록 하는 방식으로, 다양한 알고리즘을 통해 수행된다.

- **라운드로빈 방식**: 서버에 도착한 요청을 순서대로 돌아가며 분배하는 방법으로, 서버의 사양이 동일하고 세션이 오래 지속되지 않을 때 적합하다.
    
- **가중 라운드로빈 방식**: 각 서버에 가중치를 부여하여, 높은 가중치를 가진 서버가 더 많은 요청을 처리하도록 분배한다. 서버 간 성능 차이가 있는 경우 활용된다.
    
- **IP 해시 방식**: 클라이언트의 IP 주소를 해싱해 특정 서버에 매핑하는 방식이다. 이렇게 하면 동일한 클라이언트가 항상 같은 서버로 연결되어 세션이 유지된다.
    
- **최소 연결 방식**: 현재 연결 수가 가장 적은 서버에 요청을 전달하는 방식으로, 세션이 오래 지속되거나 트래픽이 일정하지 않을 때 효과적이다.
    
- **최소 응답 시간 방식**: 서버의 현재 연결 상태와 응답 시간을 함께 고려해 가장 빠른 응답을 제공할 수 있는 서버에 요청을 배정한다.
    

또한 로드 밸런싱 방식은 **L4와 L7 로드 밸런싱**으로 구분됩니다. L4는 네트워크 계층(IP와 포트)에 기반해 트래픽을 분배하고, L7은 애플리케이션 계층에서 헤더 정보와 콘텐츠를 분석하여 최적의 서버로 라우팅한다.  **L4**는 **속도와 단순성**이 필요할 때 유리하며, IP와 포트를 기준으로 기본적인 트래픽 분배가 필요할 때 사용된다. **L7**은 **트래픽 세부 제어**가 필요할 때 적합하며, 애플리케이션 수준에서 사용자 요청에 맞춘 정교한 트래픽 관리가 가능하다.

| 네트워크 계층 | L4 로드밸런서                                                                                                      | L7 로드밸런서                                                                                                               |
| ------- | ------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| Layer   | 전송 계층 (Transport layer)                                                                                       | 응용 계층 (Application layer)                                                                                              |
| 특징      | - TCP/UDP 포트 정보를 바탕으로 함                                                                                       | - TCP/UDP 정보는 물론 HTTP의 URI, FTP의 파일명, 쿠키 정보 등을 바탕으로 함                                                                  |
| 장점      | - 데이터 안을 들여다보지 않고 패킷 레벨에서만 로드를 분산하기 때문에 속도가 빠르고 효율이 높음<br>- 데이터의 내용을 복호화할 필요가 없기에 안전함<br>- L7 로드밸런서보다 가격이 저렴함 | - 상위 계층에서 로드를 분산하기 때문에 훨씬 더 섬세한 라우팅이 가능함<br>- 캐싱 기능을 제공함<br>- 비정상적인 트래픽을 사전에 필터링할 수 있어 서비스 안정성이 높음                     |
| 단점      | - 패킷의 내용을 살펴볼 수 없기 때문에 섬세한 라우팅이 불가능함<br>- 사용자의 IP가 수시로 바뀌는 경우라면 연속적인 서비스를 제공하기 어려움                            | - 패킷의 내용을 복호화해야 하기에 더 높은 비용을 지불해야 함<br>- 클라이언트가 로드밸런서와 인증서를 공유해야 하기 때문에 공격자가 로드밸런서를 통해서 클라이언트에 데이터에 접근할 보안 상의 위험성이 존재함 |


### L4 로드 밸런싱

**L4**는 **전송 계층**(Transport Layer, OSI 모델의 4계층)에서 트래픽을 분배한다. IP 주소와 포트 정보를 활용해 트래픽을 분산하며, 요청이 들어올 때 TCP 또는 UDP 세션의 출발지와 목적지 IP 주소, 포트 번호에 기반해 요청을 분배한다.

L4 로드 밸런서는 IP와 포트만 확인하므로 L7보다 상대적으로 빠르다. 따라서 고속으로 단순하게 트래픽을 분배할 때 유용하며, 주로 HTTP, HTTPS나 FTP, SMTP와 같은 프로토콜의 로드 밸런싱에 사용된다. 하지만 **세부적인 요청 내용**이나 **URL을 기반으로 트래픽을 분배하지 못한다.**

### L7 로드 밸런싱

**L7**은 **애플리케이션 계층**(Application Layer, OSI 모델의 7계층)에서 동작한다. IP와 포트뿐만 아니라 **HTTP 헤더, URL, 쿠키, 세션 데이터** 등을 포함해 요청 내용을 분석하여 트래픽을 분배한다.

L7 로드 밸런서는 어플리케이션 레벨의 데이터를 활용해 트래픽을 분배하므로 **URL 경로나 쿠키 값 등 세부 조건을 통해 정교하게 라우팅**이 가능하다. 이는 주로 웹 어플리케이션에서 이미지 요청을 분산 시키거나 특정 페이지 요청만 별도의 서버로 라우팅 처리 등에 활용된다. 하지만 트래픽을 깊게 분석해야 하므로 L4보다 [[용어 정리#오버헤드|성능 오버헤드]]가 발생할 수 있다.

또한 L7 로드 밸런서의 경우 특정한 패턴을 지닌 바이러스를 감지해 네트워크를 보호할 수 있으며, DoS/DDoS와 같은 비정상적인 트래픽을 필터링할 수 있어 네트워크 보안 분야에서도 활용되고 있다.

## 세션 일관성 문제

**세션 일관성 문제(Session Consistency Issue)** 는 로드 밸런싱 환경에서 각 서버 간의 **세션 상태가 일치하지 않음으로 인해 발생하는 문제**로, 사용자가 로그인했음에도 서버에 따라 **세션 정보가 공유되지 않아 권한이 필요하거나 개인화된 데이터를 볼 수 없는 상황**을 초래한다.

![](https://i.imgur.com/lBniL8B.png)

1. A클라이언트의 로그인 요청을 보내고, 로드 밸런서가 A서버로 보냄
2. A서버의 세션에 A클라이언트의 정보가 저장되고 로그인 성공 응답 (세션 생성)
3. 동일하게 A클라이언트가 유저 정보 조회 요청을 보내고, 로드 밸런서가 B서버로 보냄(유저 정보 요청에 로그인 권한이 필요한 경우)
4. B서버의 세션에는 로그인한 사용자 정보가 없으므로 조회 실패, 로그인 페이지로 리다이렉트 처리

위와 같은 세션 일관성 문제를 해결하기 위한 방법으로 **스티키 세션**, **세션 클러스터링**, **세션 스토리지 분리** 등이 있다.


## 스티키 세션(Sticky Session)

![](https://mblogthumb-phinf.pstatic.net/20140915_121/pzkpfw3485_1410771193047eWRyd_JPEG/stb-6.jpg?type=w800)
*찰싹!*

Sticky Session은 말 그대로 클라이언트의 첫 요청에 대해 응답을 준 서버로 이후 요청을 계속 보내게 된다. 세션 정보가 없는 유저가 요청을 한 경우(첫 요청)는 로드 밸런서의 기본 알고리즘대로 요청을 전달하지만, 이 요청으로 **세션이 생성되는 경우 해당 유저의 이후 요청은 해당 서버로 고정**된다.
일반적으로 특정 서버로 요청 처리를 고정 시키는 방법은 Cookie를 사용하거나 IP Tracking 방식이 있다.

이는 가장 단순한 방법이지만 문제점을 내포하는데, **부하 집중**이나 **세션 유실**의 문제가 있다. 단순하게 첫 요청을 처리해준 서버에 클라이언트의 요청이 고정되는 방식이라 사실상 로드 밸런싱의 원래 목적을 달성할 수 없으며 **특정 서버에 트래픽이 집중될 위험성**을 가지고 있다. 또한, 위와 같이 부하가 집중되어 **서버에 장애가 발생할 경우 해당 서버가 소유한 세션 정보는 모두 유실**될 수 있다.

## 세션 클러스터링(Session Clustering)

![](https://i.imgur.com/ibXTNEb.png)

세션 클러스터링은 각 서버 간에 세션을 복제하여 **모든 서버에 동일한 세션 상태를 전파**하는 방식이다. 이를 통해 어느 서버에 요청이 도착하더라도, 동일한 세션 정보에 접근할 수 있어 **세션 일관성**을 유지할 수 있다.

클러스터에 속한 모든 서버는 한 서버에서 세션이 생성되거나 변경 될 때, 이 변경사항이 다른 서버에도 즉시 전파된다. 이는 실시간으로 동기화되어 각 서버가 사용자의 최신 상태를 유지할 수 있다.

이 방식은 클라이언트가 어느 서버에 연결되더라도 세션 상태가 유지되고, 특정 서버에 장애가 발생하더라도 **다른 서버에서 동일한 세션 정보로 사용자의 요청을 처리**할 수 있다. 하지만 **서버가 많아질 수록 세션 동기화에 따른 네트워크 오버헤드가 증가**할 수 있고, 세션 복제 작업이 클러스터 성능에 영향을 미칠 수 있다. 이로 인해 세션 전파 및 복제 과정에서 시간 지연으로 세션 불일치 이슈가 발생할 위험성 또한 존재한다.

## 중앙 세션 저장소 (세션 스토리지 분리)

![](https://i.imgur.com/HbNzZM0.png)

위 방식은 세션 스토리지를 외부 서버로 분리하는 방식이다. 이때 사용되는 외부 세션 스토리지 서버는 일반적인 Disk-Based DB (MySQL, PostgreSQL, MongoDB 등)를 사용할 수 있지만 모든 서버의 세션을 공유하는 스토리지 특성 상 I/O 성능이 느린 데이터베이스는 사용하기 적절하지 않다.

따라서 I/O가 빠른 In-Memory DB를 사용하는 것이 일반적이며 대표적인 Key-Value DB인 Redis나 Memcached를 사용한다.

세션에 관련된(생성, 정보 요청 등) 기능을 중앙 세션 저장소에서 담당하고 각 서버는 세션 요청을 중앙 세션 저장소로 보내게 된다. 이 방식은 스티키 세션의 부하 집중 문제나 가용성 문제를 해결할 수 있고 세션 클러스터링의 메모리 비효율 문제, 네트워크 트래픽 증가, 시간 차이로 인한 세션 불일치 문제 또한 해결된다.

하지만 하나뿐인 세션 스토리지에 장애가 발생할 경우(SPOF, Single Point of Failure - 단일 장애 지점) 모든 세션 데이터가 손실될 수 있어 이를 방지하기 위해 **세션 스토리지의 고가용성**을 고려해야 한다. 해당 문제를 Redis에서는 **Redis Sentinel** 또는 **Redis Cluster**와 같은 고가용성 구성을 통해 세션 스토리지를 이중화하거나 복제본을 생성하여 장애에 대비할 수 있다.



## 참조

[Sticky Session과 Session Clustering 이해하기](https://cloud-oky.tistory.com/397)
[로드 밸런싱에 대해 알아보자!](https://tecoble.techcourse.co.kr/post/2021-11-07-load-balancing/)
[서버는 수많은 트래픽을 어떻게 견딜까?](https://maily.so/grabnews/posts/ecbe33)
[다중 서버 환경에서의 세션 불일치 문제와 해결방법](https://hudi.blog/session-consistency-issue/)

- ChatGPT
	- 로드 밸런싱은 Scale Out 방식의 서버 확장떄문에 등장하게 된 개념인가?
	- L4, L7 로드밸런싱의 차이
	- 세션 클러스터링의 세션을 하나로 묶어 관리한다는 것은 각 서버끼리 복제된 세션을 전파하는 방식인가?
