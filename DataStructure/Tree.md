
## 트리란?

![](https://i.imgur.com/uNY6hcP.png)

~~트리는 나무입니다.~~

자료구조에서의 **트리**는 나무 모양의 계층 구조를 가진 **그래프의 특수한 형태**이다. 일반적으로 트리는 하나의 **루트 노드**에서 시작하여, 여러 **자식 노드**로 뻗어 나가는 형태를 가지고 있다.

트리는 **비순환적**이고 **연결된 그래프**라는 점에서 일반 그래프와 차별화되며, 데이터가 위에서 아래로 흐르거나 상하 관계를 표현하는 데 유용하게 사용된다. 주로 계층적 관계나 조직도와 같은 구조에서 많이 활용된다.


> 트리를 알기 이전에...
> 그래프와 노드의 개념을 우선적으로 알면 좋다.

### 그래프의 간략한 설명

그래프는 여러 **노드**(정점)와 이들을 연결하는 **간선**(Edge)으로 이루어진 자료 구조로 노드들 사이에 연결 관계를 표현할 때 주로 사용되며, 그래프는 방향성, 연결성, 순환성 여부에 따라 다양한 형태로 나뉩니다.

소셜 네트워크에서 사람들 사이의 관계를 표현하는 그래프, 도로망에서 도시 간 연결을 그래프로 표현할 수 있다.

아래는 A지점에서 B지점으로 가는 여러 경로를 표현할 때, 특정 노드 사이에 여러 간선이 존재할 수 있는 형태의 예시다.

이를 표현하기 위해 인접 리스트를 사용하여 경로를 여러개 추가하는 형태로 설정되었다.

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Node {
    String name;  // 노드 이름 (예: "A", "B")

    public Node(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return name;
    }
}

class Graph {
    private Map<Node, List<Node>> adjList;  // 인접 리스트 형태로 그래프 표현

    public Graph() {
        this.adjList = new HashMap<>();
    }

    // 그래프에 노드 추가
    public void addNode(Node node) {
        adjList.putIfAbsent(node, new ArrayList<>());
    }

    // 두 노드 사이에 간선 추가 (경로 추가)
    public void addEdge(Node source, Node destination) {
        adjList.get(source).add(destination);
    }

    // 그래프 출력
    public void printGraph() {
        for (Node node : adjList.keySet()) {
            System.out.print("Node " + node.name + " is connected to: ");
            for (Node neighbor : adjList.get(node)) {
                System.out.print(neighbor.name + " ");
            }
            System.out.println();
        }
    }

    // 특정 노드 간의 경로를 찾기 위한 메서드
    public void findPaths(Node start, Node end, List<Node> path) {
        path.add(start);

        if (start.equals(end)) {
            System.out.println(path);
        } else if (adjList.containsKey(start)) {
            for (Node neighbor : adjList.get(start)) {
                if (!path.contains(neighbor)) {
                    findPaths(neighbor, end, new ArrayList<>(path));
                }
            }
        }
    }
}
```

### 노드의 간략한 설명

**노드**는 자료구조에서 흔히 사용되는 **데이터의 기본 단위**로, 그 자체만으로는 완전한 자료구조가 되기 어렵다. 노드는 보통 특정 자료구조의 한 부분으로 사용되며, 노드들이 **어떻게 연결되고, 어떻게 구조화되느냐에 따라** 자료구조의 형태와 특성이 결정됩니다. 즉, 단일 노드 자체로는 자료구조라고 하기 어렵고, 노드들이 모여 특정 구조를 이루면서 **자료구조의 역할**을 하게 된다.

1. 연결 리스트
	- 각 *노드*가 다음 *노드*를 가리키는 방식으로 연결된 구조
2. 트리
	- *노드*가 계층 구조를 이루어 부모-자식 관계로 연결된 구조
3. 그래프
	- 여러 *노드*가 다양한 방식으로 서로 연결되며, 계층적이거나 선형적이지 않아 다방향으로 연결된 구조
4. 트라이, B-Tree 등
	- *노드*에 특정 데이터나 상태를 담아 효율적인 탐색을 가능하게 하는 정렬 구조 등

```java
class MyLinkedList<T> {
    private Node<T> head;  // 첫 번째 노드를 가리키는 포인터
    private int size = 0;  // 요소 개수

    private static class Node<T> {
        T data;
        Node<T> next;

        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }

    // 요소 추가 (리스트의 끝에 추가)
    public void add(T value) {
        Node<T> newNode = new Node<>(value);
        if (head == null) {
            head = newNode;
        } else {
            Node<T> current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
        size++;
    }

    // 특정 인덱스의 요소 반환
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index out of bounds");
        }
        Node<T> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        return current.data;
    }

    // 리스트 크기 반환
    public int size() {
        return size;
    }
}

```

## 트리 탐색

트리 탐색은 트리 구조의 모든 노드를 방문하여 데이터를 검색하거나 특정 조건을 만족하는 노드를 찾는 과정입니다. 트리에서의 탐색은 주로 **깊이 우선 탐색(DFS)** 과 **너비 우선 탐색(BFS)** 의 두 가지 방법으로 나뉜다.

### **[[Depth-first Search|깊이 우선 탐색(DFS - Depth-First-Search)]]**

트리의 깊은 부분을 먼저 탐색하는 방식으로 주로 재귀를 사용하거나 스택을 이용하여 구현할 수 있으며, 전위, 중위, 후위 순회의 방식으로 나뉜다.

- **전위 순회 (Preorder Traversal)**: 부모 노드 -> 왼쪽 자식 -> 오른쪽 자식 순으로 탐색
- **중위 순회 (Inorder Traversal)**: 왼쪽 자식 -> 부모 노드 -> 오른쪽 자식 순으로 탐색 (이진 탐색 트리에서 중위 순회는 값이 정렬된 순서로 출력된다.)
- **후위 순회 (Postorder Traversal)**: 왼쪽 자식 -> 오른쪽 자식 -> 부모 노드 순으로 탐색

![](https://i.imgur.com/aJ81jq7.png)

전위 순회 : 0->1->3->7->8->4->9->10->2->5->11->6

중위 순회 : 7->3->8->1->9->4->10->0->11->5->2->6

후위 순회 : 7->8->3->9->10->4->1->11->5->6->2->0

층별 순회 : 0->1->2->3->4->5->6->7->8->9->10->11

        
### **너비 우선 탐색(BFS - Breadth-First Search)**

루트에서 시작하여 같은 레벨의 모든 노드를 먼저 탐색한 뒤 다음 레벨로 넘어간다. 

BFS는 큐 자료구조를 이용해 구현하며, 트리의 넓은 부분을 우선적으로 탐색하기 때문에 **레벨 순서 탐색(Level Order Traversal)** 이라고도 불린다.

### Q. 이거 시험 문제에도 자주 나오던데, 이게 왜 중요한거냐?

각 순회 방식들은 트리의 노드를 특정한 순서로 방문하는 규칙을 가지고 있으며, 이를 통해 **트리의 데이터 구조를 효율적으로 탐색하고 처리할 수 있다**.

각 순회 방식은 **트리의 노드 탐색 순서를 달리하여 데이터를 원하는 순서대로 접근**할 수 있게 해주고 트리의 데이터 구조를 다루는 문제를 해결할 때, 순회 방법을 적절히 선택하면 효율적인 알고리즘을 설계할 수 있다.

#### 전위, 중위, 후위 순회의 목적과 활용

1. **전위 순회 (Pre-order Traversal)
    - **용도**: 트리의 구조를 **복사**하거나, 트리 구조를 선형화하는 데 사용
    - **예시 활용**: 트리의 구조를 그대로 복제하거나, 파일 시스템과 같은 계층 구조를 복사할 때

2. **중위 순회 (In-order Traversal)**
    - **용도**: **이진 탐색 트리**에서 중위 순회는 **값을 정렬된 순서로 출력**하는 데 사용
    - **예시 활용**: 이진 탐색 트리(BST)에서 노드의 값을 오름차순 또는 내림차순으로 출력, 트리의 모든 값을 정렬된 리스트로 변환할 때

3. **후위 순회 (Post-order Traversal)**
    - **용도**: **하위 노드를 모두 처리한 후 부모 노드를 처리**하는 방식이 필요할 때, 예를 들어 파일 시스템에서 하위 폴더와 파일을 모두 삭제한 후 상위 폴더를 삭제하는 것과 같은 경우
    - **예시 활용**: 파일 삭제, 메모리 해제 등 자식 노드를 모두 처리하고 부모 노드를 마지막에 처리해야 하는 작업에 적합

## 트리 유형

트리는 **노드 연결 방식과 구조의 특성**에 따라 다양한 유형이 존재한다.

1. **이진 트리(Binary Tree)**
    - 각 노드가 최대 두 개의 자식 노드를 가지는 트리입니다.
    - 간단한 계층 구조 표현에 유용하며, 트리 탐색에 중요한 기본 구조입니다.
2. **이진 탐색 트리(Binary Search Tree, BST)**
    - 이진 트리의 한 유형으로, 왼쪽 자식은 부모보다 작고 오른쪽 자식은 부모보다 큰 값으로 유지합니다.
    - 데이터 검색 및 삽입 속도가 빠르며, 정렬된 데이터를 빠르게 검색하는 데 적합합니다.
3. **균형 이진 트리(Balanced Binary Tree)**
    - 트리의 높이를 최소화하여 모든 리프 노드의 깊이 차이가 일정하게 유지되는 트리입니다.
    - AVL 트리와 레드-블랙 트리가 대표적입니다.
4. **완전 이진 트리(Complete Binary Tree)**
    - 모든 레벨이 완전히 채워져 있으며 마지막 레벨은 왼쪽부터 차례로 노드가 채워진 이진 트리입니다.
    - 주로 배열로 표현되어 힙 자료구조에 사용됩니다.
5. **힙(Heap)**
    - 완전 이진 트리의 형태를 가지며, 부모 노드가 자식보다 큰 값을 가지는 **최대 힙**(Max Heap)과, 부모 노드가 자식보다 작은 값을 가지는 **최소 힙**(Min Heap)으로 나뉩니다.
    - 우선순위 큐나 정렬 등에 사용됩니다.
6. **트라이(Trie)**
    - 문자열 검색을 위해 설계된 트리 자료구조로, 문자열의 각 문자를 노드로 저장하여 검색 속도를 최적화합니다.
    - 단어 자동 완성, 사전 검색 등의 애플리케이션에서 사용됩니다.
7. **B-트리, B+트리**
    - 데이터베이스 및 파일 시스템에서 대용량 데이터를 관리하는 데 효율적인 트리 자료구조입니다.
    - B-트리는 여러 자식을 가지며, 균형이 유지되도록 설계된 다방향 트리입니다.


>[!warning] 너무 많아요
>방통대 자료구조 강의에서는 7강 트리부터 시작하여 13강 멀티웨이 탐색 트리까지 강의의 절반 이상을 트리 자료구조의 개념과 변형 구조에 대해 설명하고 있다. 이는 이산수학을 포함한 자료 전반의 알고리즘 공식을 포함하는 강의이므로 본 문서의 설명에서는 제외한다.

## DB의 B-Tree 인덱스로 알아보는 트리 구조의 장점

DB교육을 받을 때 B-Tree 인덱스의 간략한 설명을 들어본 적이 있다.
I/O가 많은 테이블에 인덱스를 설정할 때는 주의하라, SELECT가 잦은 테이블에 설정하면 좋다 등

데이터베이스에서 `B-Tree` 인덱스를 사용하는 이유는 **대량의 데이터를 효율적으로 관리하고, 빠르게 검색할 수 있는 자료구조**이기 때문이다.

`B-Tree`는 삽입과 삭제가 발생해도 **균형을 유지**하도록 설계되어, 트리의 높이가 낮게 유지된다. 결과적으로 **데이터를 검색할 때 트리의 높이에 비례하는 로그(logarithmic) 시간**이 소요되므로, 검색, 삽입, 삭제 연산이 매우 효율적이다.

또한 노드 탐색 시 한 번의 디스크 접근으로 여러 데이터 페이지를 로드할 수 있어 데이터베이스에서 **디스크 I/O를 줄여 성능 최적화**가 가능하다.

`B-Tree`는 데이터가 정렬된 상태로 유지되므로, **순차적 데이터 검색 및 범위 검색**이 빠르다.

```text
                       [30]
                      /    \
             [10, 20]      [40, 50, 60]
             /     |        |         \
      [5, 8]   [15, 18]  [35, 38]   [45, 55, 58]

```

위 예시는 **3차 B-Tree(각 노드가 최대 3개의 키와 4개의 자식을 가질 수 있는 구조)** 를 가정하고 있으며, 각 키와 하위 노드가 정렬된 상태로 배치된다.

## 참조

- [트리의 개념 및 순회 방식](https://m.blog.naver.com/rlakk11/60159303809)
- ChatGPT
	- 트리와 그래프는 무엇이 다른가?
	- 노드와 트리의 간략한 자바 샘플
	- 자료구조에서 노드는 타 자료구조에서 사용되는 데이터의 기본 단위처럼 쓰이는 건가? 단일 노드는 자료구조 형태가 될 수 없어 보이는데?
	- 트리의 탐색방법
	- 트리의 유형
	- 전/중/후위 순회방식을 왜 알고있어야 하는가?
		- 근데 실제 프로그래밍에서는 중/후위 순회를 할 일이 거의 없지 않은가?(중/후위 탐색을 하려면 검색을 시작할 특정 노드에 대한 주소를 탐색 시작 시점에 알고 있어야하니까)
